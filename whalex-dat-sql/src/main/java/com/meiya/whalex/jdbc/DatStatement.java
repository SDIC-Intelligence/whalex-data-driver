package com.meiya.whalex.jdbc;

import com.meiya.whalex.db.entity.DatabaseSetting;

import com.meiya.whalex.db.module.DbModuleService;
import com.meiya.whalex.db.template.BaseDbConfTemplate;

import com.meiya.whalex.interior.db.constant.DbResourceEnum;

import com.meiya.whalex.jdbc.factory.SqlParserFactory;
import com.meiya.whalex.jdbc.parser.ISqlParser;
import com.meiya.whalex.jdbc.parser.ISqlParserWithGeneratedKeys;
import lombok.extern.slf4j.Slf4j;

import org.apache.commons.lang.StringUtils;


import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;


/**
 * dat statement对象
 *
 * @author 蔡荣桂
 * @date 2022/06/27
 * @project whalex-dat-sql
 */
@Slf4j
public class DatStatement implements Statement {

    private List<String> sqlList;

    private BaseDbConfTemplate baseDbConfTemplate;

    private DbResourceEnum dbType;

    private DatabaseSetting databaseSetting;

    //结果集
    protected ResultSet resultSet;

    //更新的数量
    private int updateCount = -1;

    //是否返回自增值（只insert有效）
    private int autoGeneratedKeys;

    private int fetchSize = 0;

    private int maxRows = 0;

    private int queryTimeout = 600;

    private DatConnection connection;

    public DatStatement(DatConnection connection, BaseDbConfTemplate baseDbConfTemplate, DbResourceEnum dbType, DatabaseSetting databaseSetting) {
        this.connection = connection;
        this.baseDbConfTemplate = baseDbConfTemplate;
        this.dbType = dbType;
        this.databaseSetting = databaseSetting;
        this.sqlList = new ArrayList<>();
    }


    protected String sqlPreHandle(String sql) throws SQLException {

        if (StringUtils.isBlank(sql)) {
            throw new SQLException("sql不能为空");
        }

        //去空格
        sql = sql.trim();

        //去;
        if (sql.trim().endsWith(";")) {
            sql = sql.trim();
            sql = sql.substring(0, sql.length() - 1);
        }

        String[] split = sql.split("\n");
        StringBuilder sqlBuilder = new StringBuilder();
        //去注释
        for (String s : split) {
            if(!s.trim().startsWith("-- ")) {
                if(sqlBuilder.length() > 0) {
                    sqlBuilder.append("\n");
                }
                sqlBuilder.append(s);
            }
        }

        if(sqlBuilder.length() == 0) {
            throw new RuntimeException("没有可执行的sql:" + sql);
        }

        return sqlBuilder.toString();
    }

    @Override
    public ResultSet executeQuery(String sql) throws SQLException {

        try {

            execute(sql, null, autoGeneratedKeys, null);
            return resultSet;

        } catch (Exception e) {
            log.error(e.getMessage());
            e.printStackTrace();
        }

        return new DatResultSet();

    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS, null);
    }

    @Override
    public void close() throws SQLException {

    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        return Integer.MAX_VALUE;
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {
    }

    @Override
    public int getMaxRows() throws SQLException {
        return maxRows;
    }

    @Override
    public void setMaxRows(int max) throws SQLException {
        if(max < 0) {
            maxRows = 0;
        }
        maxRows = max;
    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {
        log.warn(this.getClass().getName() + "#" + "setEscapeProcessing 方法是空实现");
    }

    @Override
    public int getQueryTimeout() throws SQLException {
        return queryTimeout;
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {
        if(seconds < 0) {
            throw new SQLException("查询超时时间不能小于0秒");
        }
        queryTimeout = seconds;
    }

    @Override
    public void cancel() throws SQLException {
        log.error(this.getClass().getName() + "#" + "cancel 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {
    }

    @Override
    public void setCursorName(String name) throws SQLException {
        log.error(this.getClass().getName() + "#" + "setCursorName 方法未实现");
        throw new SQLException("方法未实现");
    }


    @Override
    public boolean execute(String sql) throws SQLException {
        return execute(sql, null, Statement.NO_GENERATED_KEYS, null);
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        return resultSet;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        return updateCount;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        updateCount = - 1;
        return false;
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {
    }

    @Override
    public int getFetchDirection() throws SQLException {
        return ResultSet.FETCH_FORWARD;
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        if(rows < 0) {
            throw new SQLException("fetchSize不能小于0");
        }
        fetchSize = rows;
    }

    @Override
    public int getFetchSize() throws SQLException {
        return fetchSize;
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        log.error(this.getClass().getName() + "#" + "getResultSetConcurrency 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public int getResultSetType() throws SQLException {
        log.error(this.getClass().getName() + "#" + "getResultSetType 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        sqlList.add(sql);
    }

    @Override
    public void clearBatch() throws SQLException {
    }

    @Override
    public int[] executeBatch() throws SQLException {
        int[] ints = new int[sqlList.size()];

        for (int i = 0; i < sqlList.size(); i++) {
            int result = executeUpdate(sqlList.get(i));
            ints[i] = result;
        }

        return ints;
    }

    @Override
    public Connection getConnection() throws SQLException {
        log.error(this.getClass().getName() + "#" + "getConnection 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {
        return false;
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {

        if(autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
            return resultSet;
        }

        throw new SQLException("autoGeneratedKeys 不等于 Statement.RETURN_GENERATED_KEYS 不能获取结果");
    }

    private int executeWithGeneratedKeys(ISqlParser sqlParser,
                                         int autoGeneratedKeys,
                                         String[] columnNames) throws Exception {

        ISqlParserWithGeneratedKeys sqlParserWithGeneratedKeys = (ISqlParserWithGeneratedKeys) sqlParser;

        sqlParserWithGeneratedKeys.setAutoGeneratedKeys(autoGeneratedKeys);
        sqlParserWithGeneratedKeys.setColumnNames(columnNames);

        this.autoGeneratedKeys = autoGeneratedKeys;

        if(columnNames != null && columnNames.length > 0) {
            this.autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;
        }


        updateCount = (int) sqlParserWithGeneratedKeys.execute();

        if(resultSet == null) {
            resultSet = sqlParserWithGeneratedKeys.getGeneratedKeys();
        }else {
            // 支持批量操作，返回主键id
            ResultSet generatedKeys = sqlParserWithGeneratedKeys.getGeneratedKeys();
            DatResultSet datResultSet = (DatResultSet) resultSet;
            datResultSet.addResultSet((DatResultSet) generatedKeys);
        }

        return updateCount;

    }

    private int executeUpdate(String sql, int autoGeneratedKeys, String[] columnNames) throws SQLException {

        try {

            execute(sql, null, autoGeneratedKeys, columnNames);
            return updateCount;

        } catch (Exception e) {
            log.error(e.getMessage());
            e.printStackTrace();
        }

        return -1;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        return executeUpdate(sql, autoGeneratedKeys, null);
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {

        if(columnIndexes != null && columnIndexes.length > 0) {
            return executeUpdate(sql, Statement.RETURN_GENERATED_KEYS, null);
        }

        return executeUpdate(sql, Statement.NO_GENERATED_KEYS, null);

    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        return executeUpdate(sql, Statement.NO_GENERATED_KEYS, columnNames);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        return execute(sql, null, autoGeneratedKeys, null);
    }


    /**
     *
     * @param sql  语句
     * @param params 占位符参数
     * @param autoGeneratedKeys 是否返回id
     * @param columnNames 返回字段
     * @return
     * @throws SQLException
     */
    protected boolean execute(String sql, Object[] params, int autoGeneratedKeys, String[] columnNames) throws SQLException {
        sql  = sqlPreHandle(sql);

        try {

            //获取解析对象
            ISqlParser sqlParser = SqlParserFactory.createSqlParser(
                    sql,
                    params,
                    connection.getService(),
                    databaseSetting,
                    maxRows
            );


            if(sqlParser instanceof ISqlParserWithGeneratedKeys) {
                executeWithGeneratedKeys(sqlParser, autoGeneratedKeys, columnNames);
                return false;
            }

            Object result = sqlParser.execute();

            if(result instanceof DatResultSet) {
                resultSet = (ResultSet) result;

                return true;
            }

            if (result instanceof Integer) {
                updateCount = (int) result;
            }

            return false;

        } catch (SQLException e){
            throw e;
        } catch (RuntimeException e) {
            throw e;
        }catch (Exception e) {
            log.error(e.getMessage());
            e.printStackTrace();
        }

        return false;
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {

        if(columnIndexes != null && columnIndexes.length > 0) {
            return execute(sql, null, Statement.RETURN_GENERATED_KEYS, null);
        }

        return execute(sql, null, Statement.NO_GENERATED_KEYS, null);
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        return execute(sql, null, Statement.NO_GENERATED_KEYS, columnNames);
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        log.error(this.getClass().getName() + "#" + "getResultSetHoldability 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public boolean isClosed() throws SQLException {
        return false;
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {
        log.error(this.getClass().getName() + "#" + "setPoolable 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public boolean isPoolable() throws SQLException {
        log.error(this.getClass().getName() + "#" + "isPoolable 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public void closeOnCompletion() throws SQLException {
        log.error(this.getClass().getName() + "#" + "closeOnCompletion 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        log.error(this.getClass().getName() + "#" + "isCloseOnCompletion 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        log.error(this.getClass().getName() + "#" + "unwrap 方法未实现");
        throw new SQLException("方法未实现");
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        log.error(this.getClass().getName() + "#" + "isWrapperFor 方法未实现");
        throw new SQLException("方法未实现");
    }
}
