package com.meiya.whalex.sql2dsl.parser;

import cn.hutool.core.collection.CollectionUtil;
import cn.hutool.json.JSONArray;
import cn.hutool.json.JSONUtil;
import com.meiya.whalex.db.builder.AddRecordBuilder;
import com.meiya.whalex.db.builder.UpsertRecordBatchBuilder;
import com.meiya.whalex.db.builder.UpsertRecordBuilder;
import com.meiya.whalex.db.entity.AddParamCondition;
import com.meiya.whalex.db.entity.UpsertParamBatchCondition;
import com.meiya.whalex.db.entity.UpsertParamCondition;
import lombok.extern.slf4j.Slf4j;
import org.apache.calcite.sql.parser.SqlParseException;
import org.apache.commons.collections.CollectionUtils;
import org.apache.commons.lang3.StringUtils;

import java.sql.Statement;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.function.Function;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 新增数据sql解析
 *
 * @author 蔡荣桂
 * @date 2022/06/27
 * @project whalex-dat-sql
 */
@Slf4j
public class InsertSqlToDslParser<T> extends AbstractSqlToDslParser<T> {

    private String tableName;

    private List<String> columns;

    private List<String> conflictColumns;

    private List<List> values;

    private List<String> updateColumns;

    private List<Object> updateValues;

    private String sql;

    private Object[] params;

    private int autoGeneratedKeys;

    private String[] columnNames;

    private int index;

    private boolean isBatch;

    public InsertSqlToDslParser(String sql, Object[] params) {
        this.sql = sql;
        this.params = params;
        this.index = 0;
    }

    @Override
    public T handle() throws SqlParseException {

        Queue<String> queue = parserWord(sql.toCharArray());

        //表名
        tableName = getTableName(queue);

        //判断是否是insert into table select 格式(查询插入)
        if(queue.element().equalsIgnoreCase("select")) {
            return null;
        }

        //字段
        columns = getColumns(queue);

        //判断是否是insert into table() select 格式(查询插入)
        if(queue.element().equalsIgnoreCase("select")) {
            return null;
        }

        //值
        values = getRecords(queue);

        if (!queue.isEmpty()) {

            //有新增或更新操作 on conflict
            conflictColumns = getConflictColumns(queue);

            //更新字段和值
            handleUpdateColumnsAndValues(queue);
        }

        if (StringUtils.isBlank(tableName)) {
            throw new RuntimeException("表名不能为空");
        }

        if (CollectionUtils.isEmpty(columns)
                || CollectionUtils.isEmpty(values)) {
            throw new RuntimeException("字段或值不能为空");
        }

        List<Map<String, Object>> fieldValueList = new ArrayList<>();

        for (List<Object> fieldList : values) {
            Map<String, Object> params = new HashMap<>();
            for (int i = 0; i < columns.size(); i++) {
                params.put(columns.get(i), fieldList.get(i));
            }
            fieldValueList.add(params);
        }


        if (CollectionUtil.isEmpty(conflictColumns)) {
            return (T) insertSqlToDsl(fieldValueList);
        }

        return (T) upsertSqlToDsl(fieldValueList);
    }

    @Override
    public String getTableName() {
        return tableName;
    }

    private void handleUpdateColumnsAndValues(Queue<String> queue) {

        String doWord = queue.poll();
        String updateWord = queue.poll();
        String setWord = queue.poll();


        if (!doWord.equalsIgnoreCase("do")
                || !updateWord.equalsIgnoreCase("update")
                || !setWord.equalsIgnoreCase("set")) {
            throw new RuntimeException("未知的sql:" + sql + ",解析新增或更新, 无法识别关键字[" + doWord + " " + updateWord + " " + setWord + "], " +
                    "支持关键字[DO UPDATE SET]");
        }

        if (queue.isEmpty()) {
            throw new RuntimeException("未知的sql:" + sql + ", 不完整的语句在" + setWord + "附近");
        }

        List<String> columns = new ArrayList<>();
        List<Object> values = new ArrayList<>();


        while (true) {

            columns.add(removeQuoting(queue.poll()));

            String word = queue.poll();
            if (!word.equalsIgnoreCase("=")) {
                throw new RuntimeException("未知的sql:" + sql + ", 解析新增或更新, 无法识别操作符[" + word + "], " +
                        "支持操作符[=]");
            }

            values.add(getUpdateValue(queue));

            if (queue.isEmpty()) break;
            word = queue.poll();
            if (!word.equalsIgnoreCase(",")) {
                throw new RuntimeException("未知的sql:" + sql + ", 解析新增或更新, 无法识别关键字[" + word + "], " +
                        "支持关键字[,]");
            }

        }

        updateColumns = columns;
        updateValues = values;
    }

    private Object getUpdateValue(Queue<String> queue) {

        String word = queue.poll();

        if (!word.equalsIgnoreCase("values") && values.size() == 1) {
            return getValue(word);
        }

        if (!word.equalsIgnoreCase("values")) {
            throw new RuntimeException("未知的sql:" + sql + ", 解析更新字段, 无法识别关键字[" + word + "], " +
                    "支持关键字[VALUES]");
        }

        isBatch = true;

        List<String> values = getColumns(queue);

        if (values.size() != 1) {
            throw new RuntimeException("未知的sql:" + sql + ", 解析更新字段, 更新字段只能有一个, 当前更新字段有" + values.size() + "个");
        }

        return values.get(0);

    }

    private List<String> getConflictColumns(Queue<String> queue) {
        String onWord = queue.poll();
        String conflictWord = queue.poll();

        if (!onWord.equalsIgnoreCase("on")
                || !conflictWord.equalsIgnoreCase("conflict")) {
            throw new RuntimeException("未知的sql:" + sql + ",解析新增或更新, 无法识别关键字[" + onWord + " " + conflictWord + "], " +
                    "支持关键字[ON CONFLICT]");
        }

        return getColumns(queue);
    }

    private List<List> getRecords(Queue<String> queue) {

        List<List> recordList = new ArrayList<>();

        String word = queue.poll();

        if (!word.equalsIgnoreCase("values")) {
            throw new RuntimeException("未知的sql:" + sql + ", 解析新增数据字段, 无法识别关键字[" + word + "], " +
                    "支持关键字[VALUES]");
        }

        recordList.add(getValues(queue));

        //单条插入语句
        if (queue.isEmpty()) return recordList;

        //多条插入语句
        while (!queue.isEmpty()) {
            word = queue.element();
            if (!word.equalsIgnoreCase(",")) {
                break;
            }
            queue.poll();
            recordList.add(getValues(queue));
        }

        return recordList;
    }


    private Object jsonHandler(String jsonStr) {
        if (JSONUtil.isJsonArray(jsonStr)) {
            JSONArray jsonArray = JSONUtil.parseArray(jsonStr);
            return jsonArray.toList(Object.class);
        }

        if (JSONUtil.isJsonObj(jsonStr)) {
            return JSONUtil.toBean(jsonStr, Map.class);
        }

        return jsonStr;
    }

    private Object getValue(String value) {

        if (value.equalsIgnoreCase("?")) {
            return params[index++];
        }

        if (value.startsWith("'")) {

            //json处理
            if (value.endsWith("::json")) {
                value = value.substring(0, value.length() - 6);
                value = removeApostrophe(value);
                return jsonHandler(value);
            }

            //字符串
            if(value.endsWith("::string")) {
                value = value.substring(0, value.length() - 8);
                return removeApostrophe(value);
            }

            //没有指定类型时，默认的处理方式
            value = removeApostrophe(value);

            if (value.contains("\\\"")) {
                return value;
            }

            Pattern compile = Pattern.compile("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}");
            Matcher matcher = compile.matcher(value);
            if(matcher.matches()) {
                SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                try {
                    return format.parse(value);
                } catch (ParseException e) {
                    log.warn("时间字符符解析失败: {}", value);
                    return value;
                }
            }

            return jsonHandler(value);

        }

        if(value.startsWith("b'") && value.endsWith("'")) {
            return removeApostrophe(value.substring(1));
        }

        //boolean类型处理
        if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) {
            return Boolean.valueOf(value);
        }

        //数字类型处理
        String[] split = value.split("\\.");
        boolean isNumeric = true;
        if(split.length <= 2) {
            for (String s : split) {
                if(!StringUtils.isNumeric(s)) {
                    isNumeric = false;
                    break;
                }
            }
        }else {
            isNumeric = false;
        }

        if (isNumeric) {
            if (value.contains(".")) {
                return Double.valueOf(value);
            } else {
                return Long.valueOf(value);
            }
//            return new BigDecimal(value);
        }

        //空类型处理
        if (value.equalsIgnoreCase("null")) {
            return null;
        }

        return value;
    }

    private <T> List<T> getColumnsOrValues(Queue<String> queue, Function<String, T> handler) {

        List<T> columns = new ArrayList<>();

        String word = queue.poll();

        if (!word.equalsIgnoreCase("(")) {
            throw new RuntimeException("未知的sql:" + sql + ", 解析字段或字段值缺少(, 在" + word + "附近");
        }

        while (!queue.isEmpty()) {

            word = queue.poll();

            //处理器
            T result = handler.apply(word);

            columns.add(result);

            word = queue.poll();

            if (word.equalsIgnoreCase(",")) {
                continue;
            }

            if (word.equalsIgnoreCase(")")) {
                break;
            }

            throw new RuntimeException("未知的sql:" + sql + ", 解析字段或字段值, 无法识别关键字[" + word + "], " +
                    "支持关键字[',', ')']");
        }

        if (!word.equalsIgnoreCase(")")) {
            throw new RuntimeException("未知的sql:" + sql + ", 解析字段或字段值缺少), 在" + word + "附近");
        }

        return columns;

    }

    private List<String> getColumns(Queue<String> queue) {
        return getColumnsOrValues(queue, (item) -> {
            return removeQuoting(item);
        });
    }

    private List<Object> getValues(Queue<String> queue) {
        return getColumnsOrValues(queue, (item) -> {
            return getValue(item);
        });
    }


    private String getTableName(Queue<String> queue) {

        String insertWord = queue.poll();
        String intoWord = queue.poll();

        if (!insertWord.equalsIgnoreCase("insert")
                || !intoWord.equalsIgnoreCase("into")) {
            throw new RuntimeException("未知的sql:" + sql + ",解析插入语句, 无法识别关键字[" + insertWord + " " + intoWord + "], " +
                    "支持关键字[INSERT INTO]");
        }

        String tableName = queue.poll();

        String[] names = tableName.split("\\.");

        if (names.length == 2) {
            tableName = names[1];
        } else {
            tableName = names[0];
        }

        tableName = removeQuoting(tableName);

        return tableName;

    }

    private Object upsertSqlToDsl(List<Map<String, Object>> fieldValueList) {

        if (CollectionUtil.isEmpty(updateColumns) || CollectionUtil.isEmpty(updateValues)) {
            throw new RuntimeException("更新字段不能为空");
        }

        Map<String, Object> updateMap = new HashMap<>();

        for (int i = 0; i < updateColumns.size(); i++) {
            updateMap.put(updateColumns.get(i), updateValues.get(i));
        }

        if (isBatch) {

            UpsertParamBatchCondition upsertParamBatchCondition = UpsertRecordBatchBuilder.builder()
                    .conflictField(conflictColumns.toArray(new String[0]))
                    .withCommitNow(true)
                    .addRecordList(fieldValueList)
                    .updateKey(updateColumns.toArray(new String[0]))
                    .build();

            return upsertParamBatchCondition;

        } else {

            UpsertParamCondition upsertParamCondition = UpsertRecordBuilder.builder()
                    .conflictField(conflictColumns.toArray(new String[0]))
                    .record(fieldValueList.get(0))
                    .withCommitNow(true)
                    .update(updateMap)
                    .build();

            return upsertParamCondition;

        }

    }

    private AddParamCondition insertSqlToDsl(List<Map<String, Object>> fieldValueList) {

        AddRecordBuilder addRecordBuilder = AddRecordBuilder.builder();

        addRecordBuilder.addBatchFromMap(fieldValueList);

        if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
            addRecordBuilder.returnGeneratedKey(true);
        }

        if (columnNames != null) {
            addRecordBuilder.returnFields(Arrays.asList(columnNames));
        }

        AddParamCondition addParamCondition = addRecordBuilder.build();

        return addParamCondition;

    }


    public void setAutoGeneratedKeys(int autoGeneratedKeys) {
        this.autoGeneratedKeys = autoGeneratedKeys;
    }


    public void setColumnNames(String[] columnNames) {
        this.columnNames = columnNames;
    }
}
